%!TEX root = kotov.tex
\section{Task 2: Краскал наоборот}
\begin{task}
    Пусть дан связный взвешенный неорграф, будем рассматривать его ребра в порядке невозрастания веса и удалять текущее ребро, если связность графа при этом не нарушается.
    Докажите, что этот алгоритм находит минимальный остов, или придумайте контрпример.
\end{task}

\begin{solution}
    Будем доказывать корректность.
        Во-первых, заметим, что получающееся в конце процедуры мы получаем связанный подграф, так как при удалении проверяем связность.
        Во-вторых, надо понять, что в конце мы действительно получим дерево, ну для этого достаточно понять, что в конце в конечном подграфе не могут остаться циклы, так как в процессе обхода мы бы удалили наибольшее ребро из цикла, следовательно, разорвали бы его.
        Наконец, докажем, что получающееся дерево минимально.
        Рассмотрим простое утверждение: в любой момент времени работы алгоритма минимальное остовное дерево (т.е. множество ребер) является подмножеством текущего множества невыброшенных ребер.
        Будем работать по индукции:
        \begin{itemize}
            \item База: В начале очевидно, что когда мы еще не выбросили ни одного ребра, то среди всех ребер есть множество, которое принадлежит множеству ребер MST (тут надо воспользоваться тем, что исходный граф связный, следовательно, остовное дерево существует)
            \item Предположение: пусть утверждение верно для некоторого множества G, обозначим соответствующее MST как $T$.
            Надо показать, что после удаления ребра (то есть следующий момент алгоритма) существует остовное дерево $T'$, являющееся подмножеством $G$.
            
            Если мы удаляем ребро $e$, которое не принадлежит исходному $T$, то $T=T'$ и все хорошо в плане включения множеств, т.к. для $T$ все выполнено.
            Если же мы удаляем ребро $e$, которое принадлежит $T$, то у такого дерева нарушается связность, следовательно, оно разбивается на две компоненты $T_1$ и $T_2$, но исходное $G$ остается связанным, так как мы проверяем связность перед удалением, т.е. в таком случае у нас должен существовать путь $T_1$ и $T_2$ этими компонентами, который не проходит по удаленному ребру.
            Но тогда значит, что до удаления у нас существовал здесь цикл в $G$, но не в $T$, т.к. иначе бы $T$ не было бы деревом (я надеюсь, что мы еще не запутались в множествах), т.е. есть некоторое отличное от удаленного ребра $e$ ребро $e'$, которое принадлежит $G$, но не принадлежит $T$, тогда после удаления ребра $e$ и добавления ребра $e'$, то мы получим $T'$ --- как бы новое MST (но мы покажем, что либо $T'=T$, либо такое невозможно).
            
            Почему можем так сделать?
            Во-первых, $T'$ --- остовное дерево, так как мы связали две компоненты одним ребром (по лемме о разрезе циклов не возникло), а множество вершин, которое $T'$ покрывает, такое же, как и у $T$, которое было остовным.
            Во-вторых, $T'$ --- минимально: рассмотрим отношение между $w(T)$ и $w(T')$.
            У нас возможны в целом $3$ варианта:
            \begin{enumerate}
                \item $w(e') < w(e)$, но тогда $w(T') < w(T)$, но $T$ --- MST, следовательно, такого быть не множеств.
                \item $w(e') > w(e)$, но тогда, так как мы проходим в порядке невозрастания веса ребер, мы бы наткнулись на $e'$ раньше, чем на $e$ и удалили бы его, так как связность не нарушилась бы (напомню, что $e$ и $e'$ принадлежат одному циклу в исходном графе), но при этом мы уже показали, что $e'$ есть в $G$, следовательно, такое тоже невозможно.
                \item $w(e') = w(e)$, но тогда $w(T') = w(T)$, следовательно, $T'$ тоже MST.
             \end{enumerate}
        \end{itemize}
        Окончательно, имеем некоторое множество ребер, которое образует остовное дерево в исходном графе, и дополнительно является минимальным по весу, то есть это MST.
\end{solution}