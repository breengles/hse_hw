%!TEX root = kotov.tex
\section{Task 6}
\begin{task}
    \textit{В свободное время Анка-пулемётчица любит сортировать патроны по серийным номерам. Вот и сейчас она только разложила патроны на столе в строго отсортированном порядке, как Иван Васильевич распахнул дверь с такой силой, что все патроны на столе подпрыгнули и немного перемешались. Оставив ценные указания, Иван Васильевич отправился восвояси.  Как оказалось, патроны перемешались не сильно. Каждый патрон отклонился от своей позиции не более чем на $k$. Всего патронов $n$. Помогите Анке отсортировать патроны.}
	\textit{\begin{enumerate}
		\item Отсортируйте патроны за $\O(nk)$.
		\item Отсортируйте патроны за $\O(n + I)$, 
		где $I$ --- число инверсий.
		\item Докажите нижнюю оценку на время сортировки $\Omega(n \log k)$.
		\item Отсортируйте патроны за $\O(n \log k)$ (если вы решили этот пункт, автоматически засчитается и пункт а).
	\end{enumerate}}
\end{task}
\begin{solution}
    \begin{enumerate}[a)]
        \item Запускаем сортировку вставками (\texttt{InsertionSort}), но если для всего массива она бы проработал за $\O(n^2)$, то тут мы можем ограничить промежуток, откуда и куда вставлять, но все равно нужно будет пробежаться по всем элементам, в результате будет $\O(nk)$
        \item Формально, при выполнении одной итерации внутреннего цикла \texttt{InsertionSort} убирается одна инверсия, то есть как работает сортировка вставками: для каждого элемента мы пробегаем весь массив от текущего элемента до начала и переставляем текущий элемент с соседним слева, если они образуют инверсию, данный кусочек выполняется до тех пор, пока текущий элемент образует инверсию со своим соседом слева, то есть формально для \textit{всего} массива этот кусочек будет проделан порядка $\O(I)$, где $I$ --- число инверсий исходного массива. Внешний цикл все также пробежит по всем элементам, таким образом, мы получим время $\O(n + I)$.
        \item ---
        \item Составим min-кучу из $k+1$ патронов, начиная с первого. Выполним следующую процедуру:
        \begin{enumerate}[1)]
            \item делаем \texttt{extract\_min()}, записывая результат в результирующий массив.
            \item добавляем следующий за $k+1$-ым патроном элемент в кучу.
            \begin{remark}
                Здесь имеется в виду, что добавляется следующий патрон из оставшихся, которые не принимали участия в куче.
            \end{remark}
        \end{enumerate}
        Это все делается за $\O(\log k)$, теперь пробегаем с такой процедурой по всему массиву, в итоге получим время $\O(n\log k)$
        \begin{remark}
            Почему это работает? Мы заведомо знаем, что патроны улетели дальше $k$ от своей отсортированной позиции, то есть текущих первый, может быть самое дальшее на $k+1$-ой позиции. Создавая минкучу таких размеров мы гарантируем покрытие данного диапазона, а, вытаскивая минимум, гарантируем правильный новый порядок, потому что минимум он и в Африке минимум. Добавление же нового нерассмотренного патрона в кучу по сути просто сдвигает нашу кучу на один элемент вправо по массиву. Так до тех пор, пока порядок не будет восстановлен (здесь нет политики).
        \end{remark}
    \end{enumerate}
\end{solution}