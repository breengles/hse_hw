%!TEX root = kotov.tex
\section{Task 1: Второе по минимальности MST}
\begin{task}
    Найдите за $\O(V^2 + E)$ второе по весу остовное дерево в неографе.
\end{task}

\begin{solution}
    Давайте запускать Прима, но в процессе которого будем запоминать самое тяжелое ребро между парами любых ребер, например, мы можем позволить себе при добавлении нового ребра делать следующее: пусть оно соединяет вершины $v$ и $u$, где $v \in S$, а $u \in \bar{S}$, где $S$ текущее дерево.
    Пересчитаем для всех $v'\in S$ следующий массивчик $d[v'][u] = max(d[v'][v], (vu))$, то есть похоже на какую-то простенькую динамику на каждом шаге добавления новой вершины $u$ к вершине $v$.
    Все равно у нас это у нас мажорировано самим поиском MST, поэтому такая добавочка во внешний цикл \texttt{while not q.empty()} (здесь $q$ --- очередь с приоритетом на массиве для классического Прима) не попортит сложности.
    
    \begin{upd}
        Рассмотрим как Прим добавляет вершины: начинаем с какой-то вершины, пусть $v$, добавляем в дерево эту одну вершину (т.е. сейчас $S = v$, а $\bar{S} = G \smallsetminus S = G \smallsetminus v$), затем рассматриваем все ребра, которые соединяют вершину $v$ с вершинами из $\bar{S}$, выбираем минимальное по весу ребро (пусть $(vu)$) и добавляем эту вершинку и это ребро в наше искомое MST.


        Но теперь есть дополнительное действие, которое мы делаем, у нас есть массив, который хранит самое тяжелое ребро на пути $v \rightarrow u$: $d[v][u]$.
        То есть в этом примере на этом шаге мы бы просто записали $d[v][u] = w_{(vu)}$, на следующих итерациях классического Прима мы присоединяем какую-то вершину $u \in \bar{S}$ к какой-то вершине $v \in S$, при этом нам надо записать максимальное ребро на пути от каждой вершины, которые уже есть в дерево, до новодобавленной, но при этом мы уже знаем самое тяжелое ребро на пути от каждой вершины дерева до вершины $v$, то есть до той, к которой мы добавляем (это мы получили на каком-то из предыдущих шагов итерации).

        Для этого мы просто пробегаемся по всем вершинами из текущего дерева, то есть по всем $v' \in S$ и смотрим на самое тяжелое ребро на пути $v' \rightarrow u$, причем для этого (так как дерево) достаточно сравнить самое тяжелое ребро на пути $v' \rightarrow v$ с новодобавленным ребром и выбрать из них наибольшее. Ну и да, правильнее сказать, что мы храним пару (вес, ребро) в этом массиве.

        Зачем нам вообще этот массив? Чтобы быстро можно было отвечать на вопрос ``какое самое тяжелое ребро на пути в MST'', потому что последующая процедура поиска второго MST как раз будет разрывать искусственно сделанный цикл по этому ребру, потому что если бы мы разорвали не по этому, то мы бы получили заведомо более тяжелое дерево.
    \end{upd}

    Теперь, когда у нас есть в руках MST и такой массив самых тяжелых ребер между вершинами будем делать следующее: пробежимся по всем ребрам, которые не принадлежат построенному MST, их всего $E - V + 1$ штука, для каждого ребра $(uv) \notin T$ будем добавлять такое ребро к $T$ и удаляться самое тяжелое ребро на пути $u \leftarrow v$ (это мы делаем очень быстро за счет предподсчитанного массива самых тяжелых ребер), берем среди всех таких новых деревьев минимальное по весу. По сложности у нас был улучшенный Прим за $\O(V^2)$, еще у нас была пробежка по всем ребрам не из MST $\O(E - V)$, в итоге будет $\O(V^2 + E)$.

\end{solution}