%!TEX root = kotov.tex
\section{Task 3}
\begin{task}
    Про удаление ребер для увеличение количества компонент связности.
\end{task}

\begin{solution}
    \begin{enumerate}[a)]
        \item Поправляю процедуру, для начала предположим, что у нас связный граф.
        Будем делать следующее, выберем какую-то произвольную точку за сток и зафиксируем ее.
        Переберем все оставшиеся вершины в качестве стока и каждую итерацию будем запускать ФФ, обозначим его сложность за $F$.
        Тогда за $VF$, мы прогонимся так по всем вершинами, найдем минимальные разрезы, возьмем минимальный из них, удалим ребра найденного минимального среди всех минимальных разреза.

        Если же компонент связности много, то мы проделаем эту процедуру для каждой компоненты (почему время такое же ниже).

        Почему это корректно?
        Рассмотрим какой-то корректный ответ, то есть у нас есть какие-то две доли, соединенные некоторым количеством ребер, которые как раз соответствуют искомым в задаче.
        В нашей постановке мы как бы выбираем какую-то вершину из левой доли и перебираем все вершины из правой доли, чтобы гарантированно найти эти ребра (работает в рамках того, что пропускные способности $1$), то есть исток лежит в какой-то доли разреза, а сток --- в другой, но тут, кстати, может возникнуть проблема, если у нас много компонент связности, ну тогда мы можем просто перебрать эти компоненты этой же процедурой, тогда сложность оценивается следующей суммой $\sum V_i F_i \leq \sum V_i \max F = V\max_i F$, где $V_i$ --- число вершин (ясно, что $\sum V_i = V$), а $F_i$ --- сложность алгоритма в $i$-ой компоненте.

        \begin{remark}
            Наверно, более понятно будет сказать, что глобально нам все равно кто именно был истоком, важно лишь то, в какую долю разреза она попала (здесь можно поэксплуатировать неориентированность графа), и нужно найти вершину в другой доле.
        \end{remark}

        \item В предыдущем пункте мы очень грубо оценили $F_i$, давайте воспользуемся тем знанием, что пропускные способности всех ребер у нас равны $1$.
        Не умаляя общности рассмотрим только одну компоненту связности.
        Рассмотрим, например, алгоритм Ф-Ф: его сложность $\O(E|f|)$, где $f$ --- величина максимального потока.
        При условии, что у нас пропускные способности всех ребер $1$, то $|f| \leq \text{deg}t$, так как мы не можем выкачать в стоке больше, чем кол-во входящих ребер (а из стока ничего не выходит).

        В итоге, сложность $\O(\sum E\text{deg}t_i) = \O(E\sum\text{deg} t_i)$, но при этом мы знаем, что $\sum\text{deg} t_i = 2E$, следовательно, $\O(E^2)$.
    \end{enumerate}
\end{solution}