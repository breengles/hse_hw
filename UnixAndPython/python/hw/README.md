# Домашнее задание 

## Задачи

### Декораторы

#### 1. @profiler 

Напишите декоратор `@proﬁler`, который при вызове функции будет сохранять в её атрибуты 
время её исполнения (в секундах) и количество рекурсивных вызовов, 
произошедших при **последнем нерекурсивном** вызове функции.
Атрибуты назовите `last_time_taken` и `calls`.

Пример:

    @profiler
    def f(n):
        if n != 0:
            f(n - 1)
    
    f(5)
    f(5)
        
    f.calls # 5
    f.last_time_taken # 0.228

#### 2. @logger 

Декоратор `@logger` должен производить логирование вызовов функций.

На вход декоратор принимает путь к файлу, в который будет производиться
запись логов. Если файла по переданному пути нет, то его необходимо создать.

##### Формат логов:

    date time function_name (args) (kwargs) result

##### Пример:

    @logger('my_log.txt')
    def f(n):
        if n != 0:
            f(n - 1)
    
    f(1)

##### Результат:

    $ cat my_log.txt
    12/12/2012 2:28:00 f (0) () None
    12/12/2012 2:28:01 f (1) () None

#### 3. @cached 

Реализуйте декоратор `@cached`. Функция, к которой был применен этот декоратор, будет кэшировать результаты своей работы
на определенных аргументах. Для простоты можно считать, что у декорируемых функций нет ключевых аргументов.

Помимо этого у декоратора `cached` есть ключевой аргумент `cache_size`, имеющий значение `None` по-умолчанию.
Если `cache_size` не установлен, то продекорированная функция запоминает все посчитанные значения.
Если значение `cache_size` - натуральное число, то функция будет помнить только последние `cache_size` посчитанных
значений (при `cache_size = 0` значения не кешируются).

##### Пример:

    @cached(cache_size=1)
    def foo(a):
        ...
    
    foo(1)  # считает значение
    foo(1)  # использует закешированное значение
    foo(2)
    foo(1)  # считает значение

##### Примечания:
* При выполнении данного задания **неожиданно полезным** может оказаться **OrderedDict**.
* Пользоваться глобальными переменными **запрещено**.
* Для получения бонусного балла за задание нужно поддержать значения по-умолчанию. Например

    @cached
    def foo(a=42):
        ...
    
    foo(42)
    foo()   # использует закешированное значение
    
#### 4. @takes 

Напишите декоратор `@takes`, который будет проверять правильность типов входных аргументов функции. 

Декоратор принимает на вход типы аргументов и декорирует функцию таким образом, что она генерирует
исключение `TypeError`, если хотя бы один из её аргументов имеет неверный тип. 
        
##### Примечания:
* Число аргументов функции может быть больше, чем число типов, переданных в декоратор.
В этом случае нужно проверить типы только тех аргументов, для которых в декоратор переданы соответствующие типы. 
* Число типов, переданных в декоратор, может быть больше, чем число аргументов, переданных в функцию.
В этом случае всё равно нужно проверить типы переданных аргументов.
* Генерацию исключений воспринимайте пока как волшебный способ просигнализировать об ошибке.
Делается это так: `raise TypeError()`.
* Каноничный способ проверить тип в питоне: [`isinstance`](https://docs.python.org/3/library/functions.html#isinstance).
* Для простоты можно считать, что у функции нет именованных аргументов.


##### Пример:

    @takes(int, str)
    def f(a, b):
        pass
    
    f(1, 'ab')
    f(1, 2)    # ошибка

### 5. Ввод/вывод

В этой секции в каждой из задач требуется написать отдельный скрипт `<task_name>.py`,
который в зависимости от ситуации принимает входной поток либо из файла/файлов, либо 
из `stdin`.

#### 1. nl 
Написать упрощенный вариант утилиты `nl` - скрипт, который выдает в `stdout` пронумерованные строки из файла.
Если файл не передан, то строка читает строки из `stdin`.
Скрипт должен работать так же, как `nl -b a`.

#### 2. tail 
Написать упрощенный вариант утилиты `tail` - скрипт, выводящий в `stdout` последние 10 строк каждого из переданных файлов.
Если передано больше одного файла, то перед обработкой очередного файла необходимо вывести его имя (подробности смотрите в оригинальной утилите `tail`).
Если не передано ни одного файла, то нужно вывести последние 10 строк из `stdin`.

##### Примечания:
* В ходе работы скрипта считывать файлы в память целиком **запрещается**.

#### 3. wc 
Написать скрипт, работающий так же, как утилита `wc`, вызванная без дополнительных опций.
Т.е. для каждого переданного файла утилита выводит статистику (3 числа) и имя файла.
Если передано больше одного файла, то в самом конце утилита выводит суммарную статистику (total).
Если ни одного файла не передано, то утилита считывает весь вход и печатает для него статистику без имени.

##### Примечания:
* Обратите внимание на то, что третьим числом `wc` выводит не число символов, а число байт!

##### Пример:

    $ ./wc.py resources/colours.txt
    1045   12317   71272


#### 6. Матрицы
  * `vec_product`

    Нужно реализовать функцию product вычисляющую скалярное произведение двух векторов.
    Векторы - одинаковой длины и представлены списками чисел.
    Постарайтесь написать функцию-однострочник.

  * `matrix_transpose`

    Нужно реализовать функцию transpose которая транспонирует матрицу.
    На вход функции подается матрица в виде списка строк, строки -- это непустые списки одинаковой длины состоящие
    из произвольных питоновских объектов. Постарайтесь написать функцию-однострочник.
    
    На выходе список списков, представляющий транспонированную матрицу.

  * `matrix_product`

    Написать функцию, вычисляющую произведение двух матриц (матрица - список списков).
    Если матрицы нельзя перемножить, сгенерировать исключение (`raise ValueError()`).
  
  * `matrix_pretty_print`

    Функция печатает переданную матрицу в красивом виде.
    Формат вывода определяется вами самостоятельно, степень его красоты определяется преподавателем и отражается на ваших баллах.
    Пример красивого формата:

    ```
    >>> matrix_pretty_print([[11, -4, 6, 123], [12, -9, 2, 5]])
    -------------------------
    |  11 |  -4 |   6 | 123 |
    -------------------------
    |  12 |  -9 |   2 |   5 |
    -------------------------
    ```
    
    Для простоты можете считать, что числа состоят не более чем из 3 цифр.

#### 7. Хаскеллолисп
Написать связные списки и функции для работы с ними в хаскелло-лисповском стиле.